<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>Графік відключень електроенергії (Фінальна версія)</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #fafafa; }
    h1 { margin-bottom: 5px; }
    #updated { margin-bottom: 20px; color: #555; }
    #chart { width: 100%; max-width: 1400px; height: 800px; }
</style>
</head>
<body>

<h1 id="title">Завантаження...</h1>
<div id="updated"></div>
<div id="chart"></div>

<script>
const CSV_INFO = "https://docs.google.com/spreadsheets/d/11sNa680oNGIDLCpeUJqkWd0gpxVIFz9gaZuop-hLE_8/export?format=csv&gid=0";
const CSV_DATA = "https://docs.google.com/spreadsheets/d/11sNa680oNGIDLCpeUJqkWd0gpxVIFz9gaZuop-hLE_8/export?format=csv&gid=1945313917";

const COLOR_POWER_OFF = "#000000"; 
const START_DATE = "2025-01-01"; // Фіксована дата для осі

// Конвертує HH:MM у формат дати, який Plotly розуміє
function toPlotlyTime(t) {
    if (t === "24:00") {
        // 24:00 = 00:00 наступного дня
        return "2025-01-02 00:00:00"; 
    }
    return `${START_DATE} ${t}:00`;
}

// Конвертує HH:MM у хвилини для hover (ця функція залишається для внутрішньої логіки)
function toMinutes(t) {
    if (t === "24:00") { 
        return 1440; 
    }
    const [h, m] = t.split(":").map(Number);
    return h * 60 + m;
}

// Решта допоміжних функцій залишаються без змін, оскільки вони не стосуються візуалізації
function parseCSV(text) {
    return text.trim().split("\n");
}

async function fetchCSV(url) {
    const response = await fetch(url);
    const buffer = await response.arrayBuffer();
    return new TextDecoder("utf-8").decode(buffer);
}

async function loadInfo() {
    const csv = await fetchCSV(CSV_INFO);
    const rows = parseCSV(csv);
    const infoRow = rows[0].split(",").map(cell => cell.replace(/^"|"$/g,'').trim());
    const updatedRow = rows[1].split(",").map(cell => cell.replace(/^"|"$/g,'').trim());
    
    document.getElementById("title").textContent = `Графік погодинних відключень на ${infoRow[1]}`;
    document.getElementById("updated").textContent = `Інформація станом на ${updatedRow[1]}`;
}

async function loadChart() {
    const csv = await fetchCSV(CSV_DATA);
    const rows = parseCSV(csv);

    const groups = [];
    const outages = {};
    
    rows.forEach(row => {
        const firstCommaIndex = row.indexOf(',');
        if (firstCommaIndex === -1) return;

        let group = row.substring(0, firstCommaIndex).trim();
        let intervalsStr = row.substring(firstCommaIndex + 1).replace(/^"|"$/g, '').trim(); 
        
        if (!group || !intervalsStr || group === "Група" || group === "Group") return; 

        const cleanIntervalsStr = intervalsStr.replace(/\s/g, ''); 
        const intervals = cleanIntervalsStr.split(",").filter(s => s.includes('-') && s.length > 0); 
        
        if (intervals.length === 0) return;
        
        groups.push(group);
        outages[group] = intervals.map(interval=>{
            let [start,end] = interval.split("-").map(s=>s.trim()); 
            
            if (end === "00:00") end = "24:00"; 
            
            return [start,end]; 
        });
    });
    
    if (groups.length === 0) {
        document.getElementById("chart").innerHTML = "<div>Помилка: Не знайдено жодної групи даних. Перевірте формат CSV.</div>";
        return;
    }

    const traces = [];

    groups.forEach(group=>{
        
        const intervals = outages[group];

        intervals.forEach(interval=>{
            const startStr = interval[0];
            const endStr = interval[1];
            
            // *** ВИПРАВЛЕННЯ: Використовуємо toPlotlyTime для осі X ***
            const start_dt = toPlotlyTime(startStr);
            const end_dt = toPlotlyTime(endStr);
            
            // Якщо інтервал невалідний (час початку >= часу кінця в хвилинах)
            if (toMinutes(startStr) >= toMinutes(endStr) && endStr !== "24:00") return;

            // Відключення (чорна смуга)
            traces.push({
                x:[start_dt, end_dt], 
                y:[group,group],
                mode:"lines",
                line:{width:18,color:COLOR_POWER_OFF},
                hoverinfo:"text",
                text:`${group}: Відключення ${startStr}–${endStr === "24:00" ? "00:00" : endStr}`,
                showlegend:false,
                z: 1 
            });
        });
    });
    
    // Оскільки Plotly на осі 'date' сам визначить мітки, ми не використовуємо tickvals/ticktext

    function getCurrentTimePlotly(){
        const now=new Date();
        const dateStr = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
        const timeStr = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}:${String(now.getSeconds()).padStart(2,'0')}`;
        // Ми використовуємо фіксовану дату (2025-01-01), щоб червона лінія відображалася коректно
        return `${START_DATE} ${timeStr}`;
    }

    const layout = {
        showlegend:false,
        xaxis:{
            title:"Час",
            type: "date", // *** ВИПРАВЛЕННЯ: Встановлюємо type: 'date' ***
            range:[`${START_DATE} 00:00:00`, `2025-01-02 00:00:00`], // 24 години
            tickformat: "%H:%M", // Формат міток
            // ПРИМІТКА: dtick Plotly сам визначає, або можна встановити dtick: 3600000 (1 година в мс)
        },
        yaxis:{
            title:"Групи",
            type: "category",
            categoryorder: "array",
            categoryarray: groups
        },
        // Малюємо червону лінію поточного часу
        shapes:[{
            type:"line",
            // *** ВИКОРИСТАННЯ ЧАСУ PLOTLY ДЛЯ ЧЕРВОНОЇ ЛІНІЇ ***
            x0:getCurrentTimePlotly(), 
            x1:getCurrentTimePlotly(),
            y0:-1,
            y1:groups.length,
            line:{color:"red",width:2,dash:"dash"}
        }]
    };

    Plotly.newPlot("chart",traces,layout);

    // Оновлення червоної лінії
    setInterval(()=>{
        const current=getCurrentTimePlotly();
        Plotly.relayout("chart",{"shapes[0].x0":current,"shapes[0].x1":current});
    },10000); 
}

async function init(){
    await loadInfo();
    await loadChart();
}

init();
</script>
</body>
</html>
