<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>Графік відключень електроенергії</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #fafafa; }
    h1 { margin-bottom: 5px; }
    #updated { margin-bottom: 20px; color: #555; }
    #chart { width: 100%; max-width: 1400px; height: 800px; }
</style>
</head>
<body>

<h1 id="title">Завантаження...</h1>
<div id="updated"></div>
<div id="chart"></div>

<script>
const CSV_INFO = "https://docs.google.com/spreadsheets/d/11sNa680oNGIDLCpeUJqkWd0gpxVIFz9gaZuop-hLE_8/export?format=csv&gid=0";
const CSV_DATA = "https://docs.google.com/spreadsheets/d/11sNa680oNGIDLCpeUJqkWd0gpxVIFz9gaZuop-hLE_8/export?format=csv&gid=1945313917";

const COLOR_POWER_ON  = "#FFD700";  // жовтий
const COLOR_POWER_OFF = "#000000";  // чорний

function toMinutes(t) {
    const [h, m] = t.split(":").map(Number);
    return h * 60 + m;
}

async function fetchCSV(url) {
    const response = await fetch(url);
    const buffer = await response.arrayBuffer();
    return new TextDecoder("utf-8").decode(buffer);
}

// ✅ НОВИЙ ПРАВИЛЬНИЙ ПАРСЕР CSV З УРАХУВАННЯМ ЛАПОК
function parseCSV(text) {
    const lines = text.trim().split("\n");
    return lines.map(line => {
        const cells = [];
        let current = "";
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
            const c = line[i];

            if (c === '"') {
                // подвійні лапки "" всередині поля -> одна лапка
                if (inQuotes && line[i + 1] === '"') {
                    current += '"';
                    i++; // пропускаємо другу лапку
                } else {
                    inQuotes = !inQuotes;
                }
            } else if (c === ',' && !inQuotes) {
                // кінець клітинки
                cells.push(current.trim());
                current = "";
            } else {
                current += c;
            }
        }
        cells.push(current.trim());

        return cells.map(cell => cell.replace(/^"|"$/g, "").trim());
    });
}

async function loadInfo() {
    const csv = await fetchCSV(CSV_INFO);
    const rows = parseCSV(csv);
    document.getElementById("title").textContent   = `Графік погодинних відключень на ${rows[0][1]}`;
    document.getElementById("updated").textContent = `Інформація станом на ${rows[1][1]}`;
}

async function loadChart() {
    const csv = await fetchCSV(CSV_DATA);
    const rows = parseCSV(csv);

    const groups = [];
    const outages = {};

    // Беремо назву групи з першого стовпця, інтервали — з другого (як було в тебе спочатку)
    for (let i = 0; i < rows.length; i++) {
        const group = rows[i][0];
        groups.push(group);

        const intervalsStr = rows[i][1] || "";

        // У ЦЬОМУ МІСЦІ тепер rows[i][1] — це вже ЦІЛА клітинка з усіма інтервалами,
        // навіть якщо в ній були лапки й коми.
        const intervals = intervalsStr
            .split(",")
            .map(s => s.trim())
            .filter(s => s.length > 0);

        outages[group] = intervals.map(interval => {
            const [start, end] = interval.split("-").map(s => s.trim());
            return [start, end];  // ["HH:MM", "HH:MM"]
        });
    }

    const traces = [];

    // Логіка побудови сегментів — така ж, як у твоєму оригінальному коді
    groups.forEach(group => {
        let last = 0;
        const intervals = outages[group];

        intervals.forEach(interval => {
            const start = toMinutes(interval[0]);
            const end   = toMinutes(interval[1]);

            if (start > last) {
                // Електроенергія ДО відключення
                traces.push({
                    x: [last, start],
                    y: [group, group],
                    mode: "lines",
                    line: { width: 18, color: COLOR_POWER_ON },
                    hoverinfo: "text",
                    text: `${group}: Електроенергія є`,
                    showlegend: false
                });
            }

            // ВІДКЛЮЧЕННЯ
            traces.push({
                x: [start, end],
                y: [group, group],
                mode: "lines",
                line: { width: 18, color: COLOR_POWER_OFF },
                hoverinfo: "text",
                text: `${group}: Відключення ${interval[0]}–${interval[1]}`,
                showlegend: false
            });

            last = end;
        });

        // Хвіст зі світлом до кінця доби
        if (last < 1440) {
            traces.push({
                x: [last, 1440],
                y: [group, group],
                mode: "lines",
                line: { width: 18, color: COLOR_POWER_ON },
                hoverinfo: "text",
                text: `${group}: Електроенергія є`,
                showlegend: false
            });
        }
    });

    function getCurrentMinutes() {
        const now = new Date();
        return now.getHours() * 60 + now.getMinutes();
    }

    const layout = {
        showlegend: false,
        xaxis: {
            title: "Час",
            range: [0, 1440], // поки що лишаємо ПОВНІ 24 години
            tickvals: Array.from({ length: 25 }, (_, i) => i * 60),
            ticktext: Array.from({ length: 25 }, (_, i) => `${i}:00`)
        },
        yaxis: {
            title: "Групи",
            type: "category",
            categoryorder: "array",
            categoryarray: groups
        },
        shapes: [{
            type: "line",
            x0: getCurrentMinutes(),
            x1: getCurrentMinutes(),
            y0: -1,
            y1: groups.length,
            line: { color: "red", width: 2, dash: "dash" }
        }]
    };

    Plotly.newPlot("chart", traces, layout);

    // Оновлення червоної лінії раз на хвилину
    setInterval(() => {
        const current = getCurrentMinutes();
        const clamped = Math.min(current, 1440);
        Plotly.relayout("chart", {
            "shapes[0].x0": clamped,
            "shapes[0].x1": clamped
        });
    }, 60000);
}

async function init() {
    await loadInfo();
    await loadChart();
}

init();
</script>
</body>
</html>
