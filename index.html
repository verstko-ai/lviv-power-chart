<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>Графік відключень електроенергії</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #fafafa; }
    h1 { margin-bottom: 5px; }
    #updated { margin-bottom: 20px; color: #555; }
    #chart { width: 100%; max-width: 1400px; height: 800px; }
</style>
</head>
<body>

<h1 id="title">Завантаження...</h1>
<div id="updated"></div>
<div id="chart"></div>

<script>
const CSV_INFO = "https://docs.google.com/spreadsheets/d/11sNa680oNGIDLCpeUJqkWd0gpxVIFz9gaZuop-hLE_8/export?format=csv&gid=0";
const CSV_DATA = "https://docs.google.com/spreadsheets/d/11sNa680oNGIDLCpeUJqkWd0gpxVIFz9gaZuop-hLE_8/export?format=csv&gid=1945313917";

const COLOR_POWER_ON = "#FFD700"; // жовтий
const COLOR_POWER_OFF = "#000000"; // чорний

// Нова функція: конвертує хвилини (0-1440) у рядок часу "HH:MM"
function toTimeStr(minutes) {
    const h = Math.floor(minutes / 60) % 24; // % 24 для 1440 хвилин (24:00)
    const m = minutes % 60;
    const hourStr = String(h).padStart(2, '0');
    const minuteStr = String(m).padStart(2, '0');
    return `${hourStr}:${minuteStr}`;
}

function toMinutes(t) {
    const [h,m] = t.split(":").map(Number);
    return h*60 + m;
}

async function fetchCSV(url) {
    const response = await fetch(url);
    const buffer = await response.arrayBuffer();
    return new TextDecoder("utf-8").decode(buffer);
}

function parseCSV(text) {
    return text.trim().split("\n").map(row => row.split(",").map(cell => cell.replace(/^"|"$/g,'').trim()));
}

async function loadInfo() {
    const csv = await fetchCSV(CSV_INFO);
    const rows = parseCSV(csv);
    document.getElementById("title").textContent = `Графік погодинних відключень на ${rows[0][1]}`;
    document.getElementById("updated").textContent = `Інформація станом на ${rows[1][1]}`;
}

async function loadChart() {
    const csv = await fetchCSV(CSV_DATA);
    const rows = parseCSV(csv);

    const groups = [];
    const outages = {};

    for(let i=0;i<rows.length;i++){
        const group = rows[i][0];
        groups.push(group);
        const intervals = rows[i][1].split(",").map(s=>s.trim());
        outages[group] = intervals.map(interval=>{
            const [start,end] = interval.split("-").map(s=>s.trim()); 
            return [start,end];
        });
    }

    const traces = [];
    const allTimePoints = new Set(); // Для збору всіх категорій часу

    groups.forEach(group=>{
        let lastMinutes = 0;
        const intervals = outages[group];

        intervals.forEach(interval=>{
            const startMinutes = toMinutes(interval[0]);
            const endMinutes = toMinutes(interval[1]);
            const startStr = interval[0];
            const endStr = interval[1];
            
            // Додаємо точки часу для категорії
            allTimePoints.add(toTimeStr(lastMinutes));
            allTimePoints.add(startStr);
            allTimePoints.add(endStr);
            allTimePoints.add("24:00"); // Щоб забезпечити кінець осі на 24:00

            // Світло є (від lastMinutes до startMinutes)
            if(startMinutes > lastMinutes){
                traces.push({
                    // *** ВИПРАВЛЕНО: Використовуємо рядки часу як категорії ***
                    x:[toTimeStr(lastMinutes), startStr],
                    y:[group,group],
                    mode:"lines",
                    line:{width:18,color:COLOR_POWER_ON},
                    hoverinfo:"text",
                    text:`${group}: Електроенергія є ${toTimeStr(lastMinutes)}–${startStr}`,
                    showlegend:false
                });
            }

            // Відключення (від startMinutes до endMinutes)
            traces.push({
                // *** ВИПРАВЛЕНО: Використовуємо рядки часу як категорії ***
                x:[startStr, endStr],
                y:[group,group],
                mode:"lines",
                line:{width:18,color:COLOR_POWER_OFF},
                hoverinfo:"text",
                text:`${group}: Відключення ${startStr}–${endStr}`,
                showlegend:false
            });

            lastMinutes = endMinutes;
        });

        // Світло є до кінця дня (від lastMinutes до 1440)
        if(lastMinutes < 1440){
            traces.push({
                // *** ВИПРАВЛЕНО: Використовуємо рядки часу як категорії, 1440 = 24:00 ***
                x:[toTimeStr(lastMinutes), "24:00"],
                y:[group,group],
                mode:"lines",
                line:{width:18,color:COLOR_POWER_ON},
                hoverinfo:"text",
                text:`${group}: Електроенергія є ${toTimeStr(lastMinutes)}–24:00`,
                showlegend:false
            });
        }
    });

    // Формуємо повний список категорій осі X, сортуючи їх
    const allTimePointsSorted = Array.from(allTimePoints).sort((a, b) => {
        return toMinutes(a) - toMinutes(b);
    });

    // Фільтруємо, залишаючи лише позначки кожної години та початку/кінця відключень
    const hourlyTicks = Array.from({length: 25}, (_, i) => toTimeStr(i * 60));
    const finalTicks = Array.from(new Set([...hourlyTicks, ...allTimePointsSorted])).sort((a, b) => toMinutes(a) - toMinutes(b));

    function getCurrentTimeStr(){
        const now=new Date();
        const h = now.getHours();
        const m = now.getMinutes();
        return String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
    }

    const layout = {
        showlegend:false,
        xaxis:{
            title:"Час",
            // *** ВИПРАВЛЕНО: Встановлюємо type: "category" ***
            type: "category", 
            // Використовуємо всі точки часу, які з'являються на графіку, як категорії
            categoryorder: "array",
            categoryarray: finalTicks,
            // Відображаємо лише годинні позначки для чистоти
            tickvals: hourlyTicks
        },
        yaxis:{
            title:"Групи",
            type: "category",
            categoryorder: "array",
            categoryarray: groups
        },
        shapes:[{
            type:"line",
            // *** ВИПРАВЛЕНО: Використовуємо getCurrentTimeStr() замість хвилин ***
            x0:getCurrentTimeStr(),
            x1:getCurrentTimeStr(),
            y0:-1,
            y1:groups.length,
            line:{color:"red",width:2,dash:"dash"}
        }]
    };

    Plotly.newPlot("chart",traces,layout);

    // Оновлення лінії поточного часу кожну хвилину
    setInterval(()=>{
        const currentTimeStr = getCurrentTimeStr();
        Plotly.relayout("chart",{"shapes[0].x0":currentTimeStr,"shapes[0].x1":currentTimeStr});
    },60000);
}

async function init(){
    await loadInfo();
    await loadChart();
}

init();
</script>
</body>
</html>
