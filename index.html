<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>–ì—Ä–∞—Ñ—ñ–∫ –≤—ñ–¥–∫–ª—é—á–µ–Ω—å</title>

<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ö°</text></svg>">
    
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
    :root {
        --bg-body: #fafafa;
        --bg-card: #ffffff;
        --text-main: #333333;
        --text-sub: #666666;
        --border-color: #dddddd;
        --hover-bg: #e0e0e0;
        --btn-bg: #f0f0f0;
        --shadow: rgba(0,0,0,0.05);
        --chart-grid: #eeeeee;
        --chart-bg: #ffffff;
        --toast-bg: #333;
        --toast-text: #fff;
        --stat-good: #4caf50;
        --stat-bad: #f44336;
    }

    [data-theme="dark"] {
        --bg-body: #121212;
        --bg-card: #1e1e1e;
        --text-main: #e0e0e0;
        --text-sub: #aaaaaa;
        --border-color: #333333;
        --hover-bg: #333333;
        --btn-bg: #2d2d2d;
        --shadow: rgba(0,0,0,0.3);
        --chart-grid: #333333;
        --chart-bg: #1e1e1e;
        --toast-bg: #ffffff;
        --toast-text: #000000;
        --stat-good: #2e7d32;
        --stat-bad: #c62828;
    }

    body { 
        font-family: 'Segoe UI', Arial, sans-serif; 
        margin: 0; 
        padding: 10px; 
        background: var(--bg-body); 
        color: var(--text-main);
        display: flex;
        flex-direction: column;
        height: 100vh;
        box-sizing: border-box;
        transition: background 0.3s, color 0.3s;
    }
    
    .header-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        flex-wrap: wrap;
        gap: 10px;
        background: var(--bg-card);
        padding: 10px;
        border-radius: 8px;
        box-shadow: 0 2px 4px var(--shadow);
        transition: background 0.3s;
    }

    .header-info { flex-grow: 1; }
    h1 { margin: 0; font-size: 1.2rem; color: var(--text-main); }
    #updated { color: var(--text-sub); font-size: 0.75rem; margin-top: 2px; }

    /* –ë–ª–æ–∫ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ */
    .stats-badge {
        display: inline-flex;
        align-items: center;
        margin-top: 5px;
        padding: 4px 8px;
        border-radius: 6px;
        font-weight: bold;
        font-size: 0.9rem;
        background: var(--btn-bg);
        color: var(--text-main);
        border: 1px solid var(--border-color);
        transition: all 0.3s;
    }
    .stats-badge.off { background: rgba(244, 67, 54, 0.1); color: var(--stat-bad); border-color: var(--stat-bad); }
    .stats-badge.on { background: rgba(76, 175, 80, 0.1); color: var(--stat-good); border-color: var(--stat-good); }

    .controls-wrapper { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }

    .selector, .refresh-btn, .theme-btn {
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-size: 1rem;
        background: var(--bg-card);
        color: var(--text-main);
        cursor: pointer;
        outline: none;
        transition: background 0.2s, border-color 0.2s, color 0.2s;
    }

    .refresh-btn, .theme-btn {
        background: var(--btn-bg);
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .selector:hover, .refresh-btn:hover:not(:disabled), .theme-btn:hover { 
        background: var(--hover-bg); 
    }
    
    .refresh-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .spin { animation: spin 1s linear infinite; }
    @keyframes spin { 100% { transform: rotate(360deg); } }

    #chart { width: 100%; flex-grow: 1; min-height: 400px; }
    .error { color: #d32f2f; font-weight: bold; padding: 20px; background: rgba(255, 0, 0, 0.1); border-radius: 4px; }
    
    .info-badge { 
        display: inline-block; 
        background: rgba(2, 119, 189, 0.15); 
        color: #0277bd; 
        padding: 2px 6px; 
        border-radius: 4px; 
        font-size: 0.7rem; 
        margin-top: 2px;
    }
    [data-theme="dark"] .info-badge { color: #4fc3f7; background: rgba(79, 195, 247, 0.15); }

    .toast {
        visibility: hidden;
        min-width: 250px;
        margin-left: -125px;
        background-color: var(--toast-bg);
        color: var(--toast-text);
        text-align: center;
        border-radius: 8px;
        padding: 16px;
        position: fixed;
        z-index: 9999;
        left: 50%;
        bottom: 30px;
        font-size: 1rem;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        opacity: 0;
        transition: opacity 0.5s, bottom 0.5s;
        border-left: 5px solid #32CD32;
    }
    .toast.show { visibility: visible; opacity: 1; bottom: 50px; }
    .toast-title { font-weight: bold; display: block; margin-bottom: 5px; font-size: 1.1rem;}
</style>
</head>
<body>

<div class="header-controls">
    <div class="header-info">
        <h1 id="title">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</h1>
        <div id="updated"></div>
        <div id="statsBadge" class="stats-badge" style="display: none;">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div>
    </div>
    <div class="controls-wrapper">
        <select id="regionSelect" class="selector" onchange="changeRegion(this.value)">
            <option value="general">–õ—å–≤—ñ–≤ —Ç–∞ –æ–±–ª–∞—Å—Ç—å</option>
        </select>
        
        <select id="groupSelect" class="selector" onchange="highlightGroup(this.value)">
            <option value="all">–í—Å—ñ –≥—Ä—É–ø–∏</option>
        </select>
        
        <button class="theme-btn" onclick="toggleTheme()" title="–ó–º—ñ–Ω–∏—Ç–∏ —Ç–µ–º—É">
            <span id="themeIcon">üåì</span>
        </button>

        <button id="refreshBtn" class="refresh-btn" onclick="manualRefresh()" title="–û–Ω–æ–≤–∏—Ç–∏ –¥–∞–Ω—ñ">
            <span id="refreshIcon">üîÑ</span>
        </button>
    </div>
</div>

<div id="chart"></div>

<div id="notificationToast" class="toast">
    <span class="toast-title">‚ö° –£–≤–∞–≥–∞!</span>
    –ì—Ä–∞—Ñ—ñ–∫ –≤—ñ–¥–∫–ª—é—á–µ–Ω—å –∑–º—ñ–Ω–∏–≤—Å—è!
</div>

<script>
// --- –ù–ê–õ–ê–®–¢–£–í–ê–ù–ù–Ø ---
const LINE_WIDTH = 30; 
const PALETTE = ['#FFA500', '#32CD32', '#1E90FF', '#9370DB', '#FF69B4', '#00CED1'];
const COLOR_POWER_OFF_LIGHT = "#333333"; 
const COLOR_POWER_OFF_DARK = "#000000"; 
const COLOR_MIDNIGHT = "#00008B"; 
const TOP_AXIS_ANCHOR = "AXIS_ACTIVATOR";
const DEFAULT_TEMPLATE = ["1.1", "1.2", "2.1", "2.2", "3.1", "3.2", "4.1", "4.2", "5.1", "5.2", "6.1", "6.2"];

const REGION_NAMES = {
    "general": "–õ—å–≤—ñ–≤ —Ç–∞ –æ–±–ª–∞—Å—Ç—å",
    "sheptytskyi": "–®–µ–ø—Ç–∏—Ü—å–∫–∏–π —Ä-–Ω",
    "stryi": "–°—Ç—Ä–∏–π—Å—å–∫–∏–π —Ä-–Ω"
};

let isUpdating = false;
let previousSchedulesStr = ""; 
let currentJsonData = null; 
let selectedRegion = localStorage.getItem('selectedRegion') || "general"; 

function initTheme() {
    const savedTheme = localStorage.getItem('theme');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
        document.documentElement.setAttribute('data-theme', 'dark');
        updateThemeIcon(true);
    } else {
        document.documentElement.setAttribute('data-theme', 'light');
        updateThemeIcon(false);
    }
}

function toggleTheme() {
    const currentTheme = document.documentElement.getAttribute('data-theme');
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    document.documentElement.setAttribute('data-theme', newTheme);
    localStorage.setItem('theme', newTheme);
    updateThemeIcon(newTheme === 'dark');
    if (currentJsonData) renderChart(currentJsonData);
}

function updateThemeIcon(isDark) {
    document.getElementById('themeIcon').innerText = isDark ? '‚òÄÔ∏è' : 'üåô';
}

initTheme();

function getGroupColor(groupName) {
    const match = groupName.match(/\d+/);
    if (match) {
        const num = parseInt(match[0]);
        return PALETTE[(num - 1) % PALETTE.length];
    }
    return PALETTE[0];
}

function toMinutes(t) {
    const [h, m] = t.split(":").map(Number);
    return h * 60 + m;
}

function parseDateKey(dateStr) {
    const parts = dateStr.split(".");
    return new Date(parts[2], parts[1] - 1, parts[0]);
}

function formatDateKey(dateObj) {
    const dd = String(dateObj.getDate()).padStart(2, '0');
    const mm = String(dateObj.getMonth() + 1).padStart(2, '0');
    const yyyy = dateObj.getFullYear();
    return `${dd}.${mm}.${yyyy}`;
}

function showNotification() {
    const toast = document.getElementById("notificationToast");
    toast.className = "toast show";
    try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); 
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        oscillator.start();
        oscillator.stop(audioCtx.currentTime + 0.2); 
    } catch (e) {}
    setTimeout(function(){ toast.className = toast.className.replace("show", ""); }, 5000);
}

function changeRegion(regionKey) {
    selectedRegion = regionKey;
    localStorage.setItem('selectedRegion', regionKey);
    if (currentJsonData) {
        renderChart(currentJsonData);
    }
}

async function manualRefresh() {
    if (isUpdating) return; 
    const btn = document.getElementById('refreshBtn');
    const icon = document.getElementById('refreshIcon');
    isUpdating = true;
    btn.disabled = true; 
    icon.classList.add('spin'); 
    try {
        await loadPowerData(); 
        await new Promise(r => setTimeout(r, 500)); 
    } catch (e) {
        console.error("Refresh failed", e);
    } finally {
        icon.classList.remove('spin');
        setTimeout(() => { btn.disabled = false; isUpdating = false; }, 10000);
    }
}

async function loadPowerData() {
    try {
        const response = await fetch('./power_data.json?v=' + new Date().getTime());
        if (!response.ok) throw new Error(`Status ${response.status}`);
        const json = await response.json();
        currentJsonData = json; 

        const currentSchedulesStr = JSON.stringify(json.schedules);
        if (previousSchedulesStr !== "" && previousSchedulesStr !== currentSchedulesStr) {
            showNotification();
        }
        previousSchedulesStr = currentSchedulesStr;

        const updateTime = json.updated_at_site || new Date(json.scan_date).toLocaleString('uk-UA');
        const updateElem = document.getElementById("updated");
        updateElem.innerHTML = `–û–Ω–æ–≤–ª–µ–Ω–æ: ${updateTime}`;

        renderChart(json);
        // –û–Ω–æ–≤–ª—é—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫ –æ–¥—Ä–∞–∑—É –ø—ñ—Å–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
        updateStatsCounter();

    } catch (error) {
        console.error(error);
        document.getElementById("updated").innerHTML = `<span class="error">–ü–æ–º–∏–ª–∫–∞: ${error.message}</span>`;
    }
}

function getRegionData(json, dateStr, regionKey) {
    if (json.schedules && json.schedules[dateStr]) {
        if (json.schedules[dateStr][regionKey]) {
            return json.schedules[dateStr][regionKey];
        }
    }
    return {};
}

// --- –§–£–ù–ö–¶–Ü–Ø –ü–Ü–î–†–ê–•–£–ù–ö–£ –í–Ü–î–ö–õ–Æ–ß–ï–ù–ò–• –ì–†–£–ü ---
function updateStatsCounter() {
    if (!currentJsonData) return;

    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const todayKey = formatDateKey(now);
    
    // –û—Ç—Ä–∏–º—É—î–º–æ –¥–∞–Ω—ñ –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Ä–µ–≥—ñ–æ–Ω—É –Ω–∞ —Å—å–æ–≥–æ–¥–Ω—ñ
    const schedule = getRegionData(currentJsonData, todayKey, selectedRegion);
    
    let offCount = 0;
    let totalGroupsChecked = 0;

    // –ü–µ—Ä–µ–±–∏—Ä–∞—î–º–æ –≤—Å—ñ –≥—Ä—É–ø–∏
    for (const group in schedule) {
        if (!group) continue;
        totalGroupsChecked++;
        const intervals = schedule[group];
        let isOff = false;

        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∫–æ–∂–µ–Ω —ñ–Ω—Ç–µ—Ä–≤–∞–ª
        for (const interval of intervals) {
            const [startStr, endStr] = interval.split("-");
            const start = toMinutes(startStr);
            const end = toMinutes(endStr);

            // –ì–û–õ–û–í–ù–ê –õ–û–ì–Ü–ö–ê: –ü–æ—á–∞—Ç–æ–∫ –≤–∫–ª—é—á–Ω–æ, –∫—ñ–Ω–µ—Ü—å –≤–∏–∫–ª—é—á–Ω–æ
            // –Ø–∫—â–æ –∑–∞—Ä–∞–∑ 18:00, –∞ —ñ–Ω—Ç–µ—Ä–≤–∞–ª –¥–æ 18:00 -> false (—Å–≤—ñ—Ç–ª–æ —î)
            // –Ø–∫—â–æ –∑–∞—Ä–∞–∑ 18:00, –∞ —ñ–Ω—Ç–µ—Ä–≤–∞–ª –∑ 18:00 -> true (—Å–≤—ñ—Ç–ª–∞ –Ω–µ–º–∞—î)
            if (currentMinutes >= start && currentMinutes < end) {
                isOff = true;
                break;
            }
        }
        if (isOff) offCount++;
    }

    const badge = document.getElementById('statsBadge');
    badge.style.display = 'inline-flex';
    
    if (offCount > 0) {
        badge.innerText = `–ó–∞—Ä–∞–∑ –±–µ–∑ —Å–≤—ñ—Ç–ª–∞: ${offCount} –≥—Ä.`;
        badge.className = 'stats-badge off';
    } else {
        badge.innerText = `–ó–∞—Ä–∞–∑ –∑—ñ —Å–≤—ñ—Ç–ª–æ–º: –≤—Å—ñ –≥—Ä—É–ø–∏`;
        badge.className = 'stats-badge on';
    }
}

function renderChart(json) {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    const chartBgColor = isDark ? '#1e1e1e' : '#ffffff';
    const gridColor = isDark ? '#333333' : '#eeeeee';
    const textColor = isDark ? '#e0e0e0' : '#333333';
    const powerOffColor = isDark ? COLOR_POWER_OFF_DARK : COLOR_POWER_OFF_LIGHT;

    let dateKeys = Object.keys(json.schedules || {}).sort((a, b) => parseDateKey(a) - parseDateKey(b));
    
    const availableRegions = new Set(["general"]); 
    dateKeys.forEach(date => {
        const regionsInDate = Object.keys(json.schedules[date]);
        regionsInDate.forEach(r => availableRegions.add(r));
    });
    updateRegionSelector([...availableRegions]);

    const today = new Date();
    today.setHours(0,0,0,0);
    const todayKey = formatDateKey(today);

    const tomorrow = new Date(today);
    tomorrow.setDate(today.getDate() + 1);
    const tomorrowKey = formatDateKey(tomorrow);

    const schedToday = getRegionData(json, todayKey, selectedRegion);
    const schedTomorrow = getRegionData(json, tomorrowKey, selectedRegion);

    const hasDataForTomorrow = Object.keys(schedTomorrow).length > 0;
    const isCombinedMode = hasDataForTomorrow;
    
    let traces = [];
    let finalGroups = new Set(); 
    
    if (selectedRegion === "general") {
        DEFAULT_TEMPLATE.forEach(g => finalGroups.add(g));
    }
    if (Object.keys(schedToday).length > 0) {
        Object.keys(schedToday).forEach(g => finalGroups.add(g));
    }
    if (isCombinedMode) {
        Object.keys(schedTomorrow).forEach(g => finalGroups.add(g));
    }

    let chartTitle = "";
    let globalXMax = 1440; 
    let globalXMin = 0;
    let midnightShape = null;

    const regionDisplayName = REGION_NAMES[selectedRegion] || selectedRegion.charAt(0).toUpperCase() + selectedRegion.slice(1);

    if (isCombinedMode) {
        chartTitle = `–ì—Ä–∞—Ñ—ñ–∫ –Ω–∞ ${todayKey} —Ç–∞ ${tomorrowKey} (${regionDisplayName})`;
        document.getElementById("updated").innerHTML += `<br><span class="info-badge">üåô –í–µ—á—ñ—Ä–Ω—ñ–π —Ä–µ–∂–∏–º (30 –≥–æ–¥)</span>`;

        const nowHour = new Date().getHours();
        const startLookback = Math.max(0, nowHour - 6); 
        globalXMin = startLookback * 60; 
        globalXMax = 1440 + 1440; 

        processDayData(schedToday, 0, traces, finalGroups, powerOffColor);
        processDayData(schedTomorrow, 1440, traces, finalGroups, powerOffColor);

        midnightShape = {
            type: 'line', x0: 1440, x1: 1440, y0: -0.5, y1: 1, 
            line: { color: COLOR_MIDNIGHT, width: 3, dash: 'dot' }, layer: 'above'
        };

    } else {
        let targetDate = todayKey;
        if (!json.schedules[todayKey] && dateKeys.length > 0) {
             targetDate = dateKeys[0];
        }

        chartTitle = `–ì—Ä–∞—Ñ—ñ–∫ –Ω–∞ ${targetDate} (${regionDisplayName})`;
        const schedTarget = getRegionData(json, targetDate, selectedRegion);
        
        if (selectedRegion === "general") {
             DEFAULT_TEMPLATE.forEach(g => finalGroups.add(g));
        }
        Object.keys(schedTarget).forEach(g => finalGroups.add(g));

        processDayData(schedTarget, 0, traces, finalGroups, powerOffColor);
    }

    document.getElementById("title").innerText = chartTitle;

    let rawGroups = [...finalGroups];
    let filteredGroups = rawGroups.filter(g => g && g.toString().trim() !== "" && g !== "0").sort();

    updateGroupSelector(filteredGroups);

    if (filteredGroups.length > 0) {
        traces.push(createAxisActivatorTrace(globalXMin, globalXMax, filteredGroups[0]));
    }

    buildChart(traces, filteredGroups, globalXMin, globalXMax, midnightShape, isCombinedMode, chartBgColor, gridColor, textColor);

    const savedGroup = localStorage.getItem('selectedGroup');
    if (savedGroup) {
        const select = document.getElementById('groupSelect');
        if (select.querySelector(`option[value="${savedGroup}"]`)) {
            select.value = savedGroup;
            highlightGroup(savedGroup);
        }
    }
}

function updateRegionSelector(regions) {
    const select = document.getElementById('regionSelect');
    const currentSelection = selectedRegion;
    select.innerHTML = ''; 
    regions.forEach(r => {
        const option = document.createElement('option');
        option.value = r;
        option.text = REGION_NAMES[r] || r.charAt(0).toUpperCase() + r.slice(1);
        select.appendChild(option);
    });

    if (regions.includes(currentSelection)) {
        select.value = currentSelection;
    } else {
        select.value = "general";
        selectedRegion = "general";
    }
}

function updateGroupSelector(groups) {
    const select = document.getElementById('groupSelect');
    const currentVal = select.value;
    select.innerHTML = '<option value="all">üëÅÔ∏è –í—Å—ñ</option>';
    groups.forEach(g => {
        const option = document.createElement('option');
        option.value = g;
        option.text = `–ì—Ä—É–ø–∞ ${g}`;
        select.appendChild(option);
    });
    if (currentVal && groups.includes(currentVal)) {
        select.value = currentVal;
    }
}

function highlightGroup(selectedGroup) {
    localStorage.setItem('selectedGroup', selectedGroup);
    const chartDiv = document.getElementById('chart');
    if (!chartDiv.data) return;

    const opacities = chartDiv.data.map(trace => {
        if (trace.name === TOP_AXIS_ANCHOR) return 0;
        if (selectedGroup === 'all') return 1;
        if (trace.y && trace.y[0] == selectedGroup) return 1; 
        return 0.1; 
    });
    Plotly.restyle('chart', { opacity: opacities });
}

function createAxisActivatorTrace(xMin, xMax, targetGroup) {
    return {
        x: [xMin, xMax], y: [targetGroup, targetGroup], 
        mode: "lines", line: { width: 0, color: 'rgba(0,0,0,0)' }, 
        opacity: 0, hoverinfo: "none", showlegend: false, 
        xaxis: 'x2', yaxis: 'y', name: TOP_AXIS_ANCHOR
    };
}

function processDayData(schedule, offset, traces, allGroups, offColor) {
    allGroups.forEach(group => {
        if (!group || group === "0") return;
        
        const intervalsStr = (schedule && schedule[group]) ? schedule[group] : [];
        const groupColor = getGroupColor(group);
        let dayStart = 0 + offset;
        let dayEnd = 1440 + offset;

        if (intervalsStr.length > 0) {
            let last = dayStart;
            const outages = intervalsStr
                .map(interval => {
                    const [s, e] = interval.split("-");
                    return { start: toMinutes(s) + offset, end: toMinutes(e) + offset };
                })
                .sort((a, b) => a.start - b.start);

            outages.forEach(({start, end}) => {
                if (start > last) {
                    traces.push(createTrace(group, last, start, groupColor, "–°–≤—ñ—Ç–ª–æ —î"));
                }
                const timeLabel = formatTime(start - offset) + " - " + formatTime(end - offset);
                traces.push(createTrace(group, start, end, offColor, `–í–Ü–î–ö–õ–Æ–ß–ï–ù–ù–Ø: ${timeLabel}`));
                last = end;
            });
            if (last < dayEnd) {
                traces.push(createTrace(group, last, dayEnd, groupColor, "–°–≤—ñ—Ç–ª–æ —î"));
            }
        } else {
            traces.push(createTrace(group, dayStart, dayEnd, groupColor, "–ë–µ–∑ –≤—ñ–¥–∫–ª—é—á–µ–Ω—å"));
        }
    });
}

function createTrace(group, start, end, color, text) {
    return {
        x: [start, end], y: [group, group], mode: "lines",
        line: { width: LINE_WIDTH, color: color }, 
        hoverinfo: "text", text: `${group}: ${text}`, showlegend: false
    };
}

function buildChart(traces, groups, xMin, xMax, midnightShape, isCombined, bgColor, gridColor, textColor) {
    const tickVals = [];
    const tickText = [];
    
    let shapes = [];

    for (let i = 0; i <= xMax; i += 60) {
        if (i < xMin) continue;
        tickVals.push(i);
        let hour = Math.floor(i / 60);
        let displayHour = hour % 24;
        let suffix = "";
        if (isCombined) {
            if (hour === 0) suffix = " (–°—å–æ–≥–æ–¥–Ω—ñ)";
            if (hour === 24) suffix = " (–ó–ê–í–¢–†–ê)";
        }
        tickText.push(`${displayHour.toString().padStart(2, '0')}:00${suffix}`);

        if (hour % 3 === 0) {
            shapes.push({
                type: 'line', layer: 'above', xref: 'x', yref: 'paper',
                x0: i, x1: i, y0: 0, y1: 1,
                line: { color: gridColor, width: 1, dash: 'solid' }
            });
        }
    }

    const totalGroups = groups.length;
    const lineYMax = totalGroups - 0.5;
    
    if (midnightShape) {
        midnightShape.y1 = lineYMax;
        shapes.push(midnightShape);
    }
    
    const currentTime = getCurrentTotalMinutes();
    
    shapes.push({
        type: "line", xref: "x", x0: currentTime, x1: currentTime,
        y0: -0.5, y1: lineYMax,
        line: { color: "#d32f2f", width: 2, dash: "solid" }, layer: 'above'
    });

    const layout = {
        margin: { t: 50, b: 40, l: 40, r: 10 },
        paper_bgcolor: bgColor,
        plot_bgcolor: bgColor,
        font: { color: textColor },
        xaxis: {
            title: "", range: [xMin, xMax], tickvals: tickVals, ticktext: tickText,
            fixedrange: true, gridcolor: gridColor, showgrid: true,
            tickfont: { color: textColor }
        },
        yaxis: {
            title: "", type: "category", categoryorder: "array", categoryarray: [...groups].reverse(),
            fixedrange: true, showgrid: true, gridcolor: gridColor, zeroline: false,
            tickfont: { color: textColor }
        },
        xaxis2: {
            title: "", overlaying: 'x', side: 'top',     
            range: [xMin, xMax], tickvals: tickVals, ticktext: tickText,
            fixedrange: true, showgrid: false, zeroline: false, automargin: true,
            tickfont: { color: textColor }
        },
        hovermode: 'closest', shapes: shapes, height: totalGroups * 50 + 80,
        annotations: [{
            x: currentTime, y: lineYMax, xref: 'x', yref: 'y',
            text: formatTime(currentTime % 1440), showarrow: false, yshift: 10,
            font: { color: '#d32f2f', size: 12, weight: 'bold' },
            bgcolor: 'rgba(255,255,255,0.9)', bordercolor: '#d32f2f',
            borderwidth: 1, borderpad: 2, opacity: 1
        }]
    };
    
    Plotly.newPlot("chart", traces, layout, {responsive: true, displayModeBar: false});
    startClockUpdate();
}

function formatTime(minutes) {
    const h = Math.floor(minutes / 60);
    const m = minutes % 60;
    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
}

function getCurrentTotalMinutes() {
    const now = new Date();
    return now.getHours() * 60 + now.getMinutes();
}

function startClockUpdate() {
    if (window.clockInterval) clearInterval(window.clockInterval);
    
    // –û–Ω–æ–≤–ª–µ–Ω–Ω—è –∫–æ–∂–Ω—É —Ö–≤–∏–ª–∏–Ω—É
    window.clockInterval = setInterval(() => {
        const current = getCurrentTotalMinutes();
        const timeStr = formatTime(current % 1440);
        
        // 1. –û–Ω–æ–≤–ª—é—î–º–æ –ª—ñ–Ω—ñ—é —á–∞—Å—É –Ω–∞ –≥—Ä–∞—Ñ—ñ–∫—É
        const chartDiv = document.getElementById('chart');
        if (chartDiv && chartDiv.layout && chartDiv.layout.shapes) {
            const lastShapeIndex = chartDiv.layout.shapes.length - 1;
            const update = {
                [`shapes[${lastShapeIndex}].x0`]: current,
                [`shapes[${lastShapeIndex}].x1`]: current,
                'annotations[0].x': current,
                'annotations[0].text': timeStr
            };
            Plotly.relayout("chart", update).catch(() => {});
        }
        
        // 2. –û–Ω–æ–≤–ª—é—î–º–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É (–ª—ñ—á–∏–ª—å–Ω–∏–∫)
        updateStatsCounter();
        
    }, 60000); // 60 —Å–µ–∫—É–Ω–¥
}

loadPowerData();
setInterval(() => loadPowerData(), 900000); 

</script>
</body>
</html>
