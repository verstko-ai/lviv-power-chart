<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>Графік відключень електроенергії</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #fafafa; }
    h1 { margin-bottom: 5px; }
    #updated { margin-bottom: 20px; color: #555; }
    #chart { width: 100%; max-width: 1400px; height: 800px; }
    .error { color: red; font-weight: bold; }
</style>
</head>
<body>

<h1 id="title">Завантаження...</h1>
<div id="updated"></div>
<div id="chart"></div>

<script>
// --- КОНФІГУРАЦІЯ ---
const LINE_WIDTH = 45; 

// Базові кольори (1-6). Якщо груп стане більше, кольори підуть по колу.
const PALETTE = [
    '#FFA500', // 1 - Помаранчевий
    '#32CD32', // 2 - Зелений
    '#1E90FF', // 3 - Синій
    '#9370DB', // 4 - Фіолетовий
    '#FF69B4', // 5 - Рожевий
    '#00CED1'  // 6 - Бірюзовий
];

const COLOR_POWER_OFF = "#000000"; 

// Шаблон груп за замовчуванням (щоб графік не був пустим, коли світло є у всіх)
const DEFAULT_TEMPLATE = [
    "1.1", "1.2", 
    "2.1", "2.2", 
    "3.1", "3.2", 
    "4.1", "4.2", 
    "5.1", "5.2", 
    "6.1", "6.2"
];

// Розумна функція кольору: працює навіть для Групи 7, 8, 99...
function getGroupColor(groupName) {
    // Намагаємось знайти першу цифру в назві групи
    const match = groupName.match(/\d+/);
    if (match) {
        const num = parseInt(match[0]);
        // (num - 1) % PALETTE.length гарантує, що ми завжди беремо колір із масиву (0..5)
        // Наприклад, група 7 отримає той самий колір, що й група 1
        return PALETTE[(num - 1) % PALETTE.length];
    }
    // Якщо в назві немає цифр (наприклад "Група А"), беремо перший колір
    return PALETTE[0];
}

function toMinutes(t) {
    const [h, m] = t.split(":").map(Number);
    return h * 60 + m;
}

async function loadPowerData() {
    try {
        const response = await fetch('./power_data.json?v=' + new Date().getTime());
        if (!response.ok) throw new Error(`Status ${response.status}`);
        const json = await response.json();

        document.getElementById("title").textContent = `Графік погодинних відключень на ${json.target_date}`;
        const updateTime = json.updated_at_site || new Date(json.scan_date).toLocaleString('uk-UA');
        document.getElementById("updated").textContent = `Інформація станом на: ${updateTime}`;

        const schedule = json.data || {};
        
        // --- ДИНАМІЧНЕ ФОРМУВАННЯ СПИСКУ ГРУП ---
        // 1. Беремо всі групи, які знайшов робот
        const foundGroups = Object.keys(schedule);
        
        // 2. Об'єднуємо їх з нашим шаблоном (Set автоматично прибирає дублікати)
        // Це гарантує:
        // - Якщо робот знайшов нову групу (7.1), вона додасться.
        // - Якщо робот не знайшов стару (1.1), вона візьметься з шаблону.
        let finalGroups = [...new Set([...DEFAULT_TEMPLATE, ...foundGroups])];
        
        // 3. Сортуємо (щоб йшли по порядку 1.1, 1.2, 2.1...)
        finalGroups.sort();

        const traces = [];

        finalGroups.forEach(group => {
            const intervalsStr = schedule[group] || []; 
            const groupColor = getGroupColor(group);

            if (intervalsStr.length > 0) {
                // Є ВІДКЛЮЧЕННЯ
                let last = 0;
                const outages = intervalsStr.map(interval => {
                    const [start, end] = interval.split("-").map(s => s.trim());
                    return [toMinutes(start), toMinutes(end)];
                });

                outages.forEach(([start, end]) => {
                    if (start > last) {
                        // Світло Є
                        traces.push(createTrace(group, last, start, groupColor, `Електроенергія є`));
                    }
                    // Світла НЕМАЄ
                    traces.push(createTrace(group, start, end, COLOR_POWER_OFF, `Відключення ${formatTime(start)} – ${formatTime(end)}`));
                    last = end;
                });

                if (last < 1440) {
                    traces.push(createTrace(group, last, 1440, groupColor, `Електроенергія є`));
                }
            } else {
                // НЕМАЄ ВІДКЛЮЧЕНЬ (Суцільна смуга)
                traces.push(createTrace(group, 0, 1440, groupColor, `Вимкнень не передбачено`));
            }
        });

        // Побудова графіку
        buildChart(traces, finalGroups);

    } catch (error) {
        console.error(error);
        document.getElementById("updated").innerHTML = `<span class="error">Помилка: ${error.message}</span>`;
    }
}

// Допоміжна функція для створення шматка графіку (щоб не копіювати код)
function createTrace(group, start, end, color, text) {
    return {
        x: [start, end],
        y: [group, group],
        mode: "lines",
        line: { width: LINE_WIDTH, color: color },
        hoverinfo: "text",
        text: `${group}: ${text}`,
        showlegend: false,
        xaxis: 'x'
    };
}

function buildChart(traces, groups) {
    const tickVals = Array.from({ length: 25 }, (_, i) => i * 60);
    const tickText = Array.from({ length: 25 }, (_, i) => `${i}:00`);

    const layout = {
        showlegend: false,
        xaxis: {
            title: "Час доби",
            range: [0, 1440],
            tickvals: tickVals,
            ticktext: tickText,
            side: 'bottom',
            fixedrange: true
        },
        xaxis2: {
            range: [0, 1440],
            tickvals: tickVals,
            ticktext: tickText,
            overlaying: 'x',
            side: 'top',
            matches: 'x',
            fixedrange: true
        },
        yaxis: {
            title: "Групи",
            type: "category",
            categoryorder: "array",
            categoryarray: [...groups].reverse() // Динамічний список груп
        },
        hovermode: 'closest',
        shapes: [{
            type: "line",
            xref: "x", 
            x0: getCurrentMinutes(),
            x1: getCurrentMinutes(),
            y0: -0.5,
            y1: groups.length - 0.5, // Висота лінії тепер залежить від кількості груп
            line: { color: "red", width: 2, dash: "dash" }
        }],
        margin: { t: 60, b: 60 } 
    };

    // Фіктивна точка для малювання верхньої шкали
    traces.push({
        x: [0, 1440],
        y: [groups[0], groups[0]],
        mode: 'markers',
        marker: { opacity: 0 },
        xaxis: 'x2',
        showlegend: false,
        hoverinfo: 'skip'
    });

    Plotly.newPlot("chart", traces, layout, {responsive: true});
    startClockUpdate();
}

function formatTime(minutes) {
    const h = Math.floor(minutes / 60);
    const m = minutes % 60;
    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
}

function getCurrentMinutes() {
    const now = new Date();
    return now.getHours() * 60 + now.getMinutes();
}

function startClockUpdate() {
    setInterval(() => {
        const current = getCurrentMinutes();
        const clamped = Math.min(current, 1440);
        Plotly.relayout("chart", { "shapes[0].x0": clamped, "shapes[0].x1": clamped });
    }, 60000);
}

// Запуск + Автооновлення
loadPowerData();
setInterval(() => { console.log("Auto-refresh"); loadPowerData(); }, 900000);

</script>
</body>
</html>
