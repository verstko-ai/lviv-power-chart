<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>–ì—Ä–∞—Ñ—ñ–∫ –≤—ñ–¥–∫–ª—é—á–µ–Ω—å</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
    body { 
        font-family: 'Segoe UI', Arial, sans-serif; 
        margin: 0; 
        padding: 10px; 
        background: #fafafa; 
        display: flex;
        flex-direction: column;
        height: 100vh;
        box-sizing: border-box;
    }
    
    .header-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        flex-wrap: wrap;
        gap: 10px;
        background: white;
        padding: 10px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .header-info { flex-grow: 1; }
    h1 { margin: 0; font-size: 1.2rem; color: #333; }
    #updated { color: #666; font-size: 0.75rem; margin-top: 2px; }

    .controls-wrapper { display: flex; gap: 8px; align-items: center; }

    .group-selector {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-size: 1rem;
        background: #fff;
        color: #333;
        cursor: pointer;
        outline: none;
    }

    .refresh-btn {
        padding: 8px 12px;
        background: #f0f0f0;
        border: 1px solid #ddd;
        border-radius: 6px;
        cursor: pointer;
        font-size: 1.1rem;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #555;
    }
    .refresh-btn:hover:not(:disabled) { background: #e0e0e0; color: #000; }
    .refresh-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .spin { animation: spin 1s linear infinite; }
    @keyframes spin { 100% { transform: rotate(360deg); } }

    #chart { width: 100%; flex-grow: 1; min-height: 400px; }
    .error { color: #d32f2f; font-weight: bold; padding: 20px; background: #ffebee; border-radius: 4px; }
    .info-badge { display: inline-block; background: #e1f5fe; color: #0277bd; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; margin-top: 2px;}
</style>
</head>
<body>

<div class="header-controls">
    <div class="header-info">
        <h1 id="title">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</h1>
        <div id="updated"></div>
    </div>
    <div class="controls-wrapper">
        <select id="groupSelect" class="group-selector" onchange="highlightGroup(this.value)">
            <option value="all">–í—Å—ñ –≥—Ä—É–ø–∏</option>
        </select>
        <button id="refreshBtn" class="refresh-btn" onclick="manualRefresh()" title="–û–Ω–æ–≤–∏—Ç–∏ –¥–∞–Ω—ñ">
            <span id="refreshIcon">üîÑ</span>
        </button>
    </div>
</div>

<div id="chart"></div>

<script>
// --- –ù–ê–õ–ê–®–¢–£–í–ê–ù–ù–Ø ---
const LINE_WIDTH = 30; 
const PALETTE = ['#FFA500', '#32CD32', '#1E90FF', '#9370DB', '#FF69B4', '#00CED1'];
const COLOR_POWER_OFF = "#333333"; 
const COLOR_MIDNIGHT = "#00008B"; 
const TOP_AXIS_ANCHOR = "AXIS_ACTIVATOR";
const DEFAULT_TEMPLATE = ["1.1", "1.2", "2.1", "2.2", "3.1", "3.2", "4.1", "4.2", "5.1", "5.2", "6.1", "6.2"];

let isUpdating = false;

function getGroupColor(groupName) {
    const match = groupName.match(/\d+/);
    if (match) {
        const num = parseInt(match[0]);
        return PALETTE[(num - 1) % PALETTE.length];
    }
    return PALETTE[0];
}

function toMinutes(t) {
    const [h, m] = t.split(":").map(Number);
    return h * 60 + m;
}

function parseDateKey(dateStr) {
    const parts = dateStr.split(".");
    return new Date(parts[2], parts[1] - 1, parts[0]);
}

async function manualRefresh() {
    if (isUpdating) return; 
    const btn = document.getElementById('refreshBtn');
    const icon = document.getElementById('refreshIcon');
    isUpdating = true;
    btn.disabled = true; 
    icon.classList.add('spin'); 

    try {
        await loadPowerData(); 
        await new Promise(r => setTimeout(r, 500)); 
    } catch (e) {
        console.error("Refresh failed", e);
    } finally {
        icon.classList.remove('spin');
        setTimeout(() => { btn.disabled = false; isUpdating = false; }, 10000);
    }
}

async function loadPowerData() {
    try {
        const response = await fetch('./power_data.json?v=' + new Date().getTime());
        if (!response.ok) throw new Error(`Status ${response.status}`);
        const json = await response.json();

        const updateTime = json.updated_at_site || new Date(json.scan_date).toLocaleString('uk-UA');
        const updateElem = document.getElementById("updated");
        updateElem.innerHTML = `–û–Ω–æ–≤–ª–µ–Ω–æ: ${updateTime}`;

        let dateKeys = Object.keys(json.schedules || {}).sort((a, b) => parseDateKey(a) - parseDateKey(b));
        if (dateKeys.length === 0) throw new Error("–î–∞–Ω—ñ –ø–æ—Ä–æ–∂–Ω—ñ");

        const today = new Date();
        today.setHours(0,0,0,0);
        
        let traces = [];
        let finalGroups = new Set(DEFAULT_TEMPLATE);
        
        const todayStr = dateKeys.find(k => parseDateKey(k).getTime() === today.getTime());
        const tomorrow = new Date(today);
        tomorrow.setDate(today.getDate() + 1);
        const tomorrowStr = dateKeys.find(k => parseDateKey(k).getTime() === tomorrow.getTime());

        let isCombinedMode = (todayStr && tomorrowStr);
        let chartTitle = "";
        let globalXMax = 1440; 
        let globalXMin = 0;

        // –ú–∞—Å–∏–≤ –¥–ª—è —Ñ—ñ–≥—É—Ä (shapes), —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î–º–æ –ø–æ—Ä–æ–∂–Ω—ñ–º, –Ω–∞–ø–æ–≤–Ω–∏–º–æ –≤ buildChart
        // –ê–ª–µ —è–∫—â–æ —Ä–µ–∂–∏–º –∫–æ–º–±—ñ–Ω–æ–≤–∞–Ω–∏–π, –¥–æ–¥–∞–º–æ –ª—ñ–Ω—ñ—é –ø—ñ–≤–Ω–æ—á—ñ –ø—ñ–∑–Ω—ñ—à–µ
        let midnightShape = null;

        if (isCombinedMode) {
            chartTitle = `–ì—Ä–∞—Ñ—ñ–∫ –Ω–∞ ${todayStr} —Ç–∞ ${tomorrowStr}`;
            updateElem.innerHTML += `<br><span class="info-badge">üåô –í–µ—á—ñ—Ä–Ω—ñ–π —Ä–µ–∂–∏–º (30 –≥–æ–¥)</span>`;

            Object.keys(json.schedules[todayStr]).forEach(g => finalGroups.add(g));
            Object.keys(json.schedules[tomorrowStr]).forEach(g => finalGroups.add(g));
            
            const nowHour = new Date().getHours();
            const startLookback = Math.max(0, nowHour - 6); 
            globalXMin = startLookback * 60; 
            globalXMax = 1440 + 1440; 

            processDayData(json.schedules[todayStr], 0, traces, finalGroups);
            processDayData(json.schedules[tomorrowStr], 1440, traces, finalGroups);

            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —à–µ–π–ø –ø—ñ–≤–Ω–æ—á—ñ, —â–æ–± –¥–æ–¥–∞—Ç–∏ –π–æ–≥–æ –ø—ñ–∑–Ω—ñ—à–µ –≤ buildChart
            midnightShape = {
                type: 'line',
                x0: 1440, x1: 1440,
                y0: -0.5, y1: 1, // y1 –æ–Ω–æ–≤–∏—Ç—å—Å—è –ø—ñ–∑–Ω—ñ—à–µ
                line: { color: COLOR_MIDNIGHT, width: 3, dash: 'dot' },
                layer: 'above' // –ü—ñ–≤–Ω—ñ—á —Ç–µ–∂ –∑–≤–µ—Ä—Ö—É
            };

        } else {
            const targetDate = todayStr || dateKeys[0];
            chartTitle = `–ì—Ä–∞—Ñ—ñ–∫ –Ω–∞ ${targetDate}`;
            Object.keys(json.schedules[targetDate]).forEach(g => finalGroups.add(g));
            processDayData(json.schedules[targetDate], 0, traces, finalGroups);
        }

        document.getElementById("title").innerText = chartTitle;

        let rawGroups = [...finalGroups];
        let filteredGroups = rawGroups.filter(g => g && g.toString().trim() !== "" && g !== "0").sort();

        updateGroupSelector(filteredGroups);

        if (filteredGroups.length > 0) {
            traces.push(createAxisActivatorTrace(globalXMin, globalXMax, filteredGroups[0]));
        }

        buildChart(traces, filteredGroups, globalXMin, globalXMax, midnightShape, isCombinedMode);

        const savedGroup = localStorage.getItem('selectedGroup');
        if (savedGroup) {
            const select = document.getElementById('groupSelect');
            if (select.querySelector(`option[value="${savedGroup}"]`)) {
                select.value = savedGroup;
                highlightGroup(savedGroup);
            }
        }

    } catch (error) {
        console.error(error);
        document.getElementById("updated").innerHTML = `<span class="error">–ü–æ–º–∏–ª–∫–∞: ${error.message}</span>`;
    }
}

function updateGroupSelector(groups) {
    const select = document.getElementById('groupSelect');
    const currentVal = select.value;
    select.innerHTML = '<option value="all">üëÅÔ∏è –í—Å—ñ</option>';
    groups.forEach(g => {
        const option = document.createElement('option');
        option.value = g;
        option.text = `–ì—Ä—É–ø–∞ ${g}`;
        select.appendChild(option);
    });
    if (currentVal && groups.includes(currentVal)) {
        select.value = currentVal;
    }
}

function highlightGroup(selectedGroup) {
    localStorage.setItem('selectedGroup', selectedGroup);
    const chartDiv = document.getElementById('chart');
    if (!chartDiv.data) return;

    const opacities = chartDiv.data.map(trace => {
        if (trace.name === TOP_AXIS_ANCHOR) return 0;
        if (selectedGroup === 'all') return 1;
        if (trace.y && trace.y[0] == selectedGroup) return 1; 
        return 0.1; 
    });
    Plotly.restyle('chart', { opacity: opacities });
}

function createAxisActivatorTrace(xMin, xMax, targetGroup) {
    return {
        x: [xMin, xMax], y: [targetGroup, targetGroup], 
        mode: "lines", line: { width: 0, color: 'rgba(0,0,0,0)' }, 
        opacity: 0, hoverinfo: "none", showlegend: false, 
        xaxis: 'x2', yaxis: 'y', name: TOP_AXIS_ANCHOR
    };
}

function processDayData(schedule, offset, traces, allGroups) {
    allGroups.forEach(group => {
        if (!group || group === "0") return;
        const intervalsStr = schedule[group] || [];
        const groupColor = getGroupColor(group);
        let dayStart = 0 + offset;
        let dayEnd = 1440 + offset;

        if (intervalsStr.length > 0) {
            let last = dayStart;
            const outages = intervalsStr.map(interval => {
                const [s, e] = interval.split("-");
                return [toMinutes(s) + offset, toMinutes(e) + offset];
            });
            outages.forEach(([start, end]) => {
                if (start > last) {
                    traces.push(createTrace(group, last, start, groupColor, "–°–≤—ñ—Ç–ª–æ —î"));
                }
                const timeLabel = formatTime(start - offset) + " - " + formatTime(end - offset);
                traces.push(createTrace(group, start, end, COLOR_POWER_OFF, `–í–Ü–î–ö–õ–Æ–ß–ï–ù–ù–Ø: ${timeLabel}`));
                last = end;
            });
            if (last < dayEnd) {
                traces.push(createTrace(group, last, dayEnd, groupColor, "–°–≤—ñ—Ç–ª–æ —î"));
            }
        } else {
            traces.push(createTrace(group, dayStart, dayEnd, groupColor, "–ë–µ–∑ –≤—ñ–¥–∫–ª—é—á–µ–Ω—å"));
        }
    });
}

function createTrace(group, start, end, color, text) {
    return {
        x: [start, end], y: [group, group], mode: "lines",
        line: { width: LINE_WIDTH, color: color }, 
        hoverinfo: "text", text: `${group}: ${text}`, showlegend: false
    };
}

function buildChart(traces, groups, xMin, xMax, midnightShape, isCombined) {
    const tickVals = [];
    const tickText = [];
    
    // –ú–∞—Å–∏–≤ –¥–ª—è –≤—Å—ñ—Ö —Ñ—ñ–≥—É—Ä (—Å—ñ—Ç–∫–∞ + –ª—ñ–Ω—ñ—ó —á–∞—Å—É)
    let shapes = [];

    // --- –ì–ï–ù–ï–†–ê–¶–Ü–Ø –°–Ü–¢–ö–ò –¢–ê –ú–Ü–¢–û–ö ---
    for (let i = 0; i <= xMax; i += 60) {
        if (i < xMin) continue;
        
        tickVals.push(i);
        let hour = Math.floor(i / 60);
        let displayHour = hour % 24;
        let suffix = "";
        if (isCombined) {
            if (hour === 0) suffix = " (–°—å–æ–≥–æ–¥–Ω—ñ)";
            if (hour === 24) suffix = " (–ó–ê–í–¢–†–ê)";
        }
        tickText.push(`${displayHour.toString().padStart(2, '0')}:00${suffix}`);

        // ** –ù–û–í–ê –õ–û–ì–Ü–ö–ê –°–Ü–¢–ö–ò (–ö–æ–∂–Ω—ñ 3 –≥–æ–¥–∏–Ω–∏ –ø–æ–≤–µ—Ä—Ö —Å–º—É–≥) **
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –≥–æ–¥–∏–Ω–∞ –∫—Ä–∞—Ç–Ω–∞ 3 (0, 3, 6, 9...)
        if (hour % 3 === 0) {
            shapes.push({
                type: 'line',
                layer: 'above', // –ú–∞–ª—é—î–º–æ –ü–û–í–ï–†–• —Å–º—É–≥
                xref: 'x', yref: 'paper', // yref: paper –æ–∑–Ω–∞—á–∞—î –≤—ñ–¥ –Ω–∏–∑—É –¥–æ –≤–µ—Ä—Ö—É –≤—Å—å–æ–≥–æ –≥—Ä–∞—Ñ—ñ–∫—É
                x0: i, x1: i,
                y0: 0, y1: 1,
                line: { 
                    color: 'rgba(0, 0, 0, 0.15)', // –ù–∞–ø—ñ–≤–ø—Ä–æ–∑–æ—Ä–∏–π —á–æ—Ä–Ω–∏–π
                    width: 1,
                    dash: 'solid' 
                }
            });
        }
    }

    const totalGroups = groups.length;
    const lineYMax = totalGroups - 0.5;
    
    // –î–æ–¥–∞—î–º–æ –ª—ñ–Ω—ñ—é –ø—ñ–≤–Ω–æ—á—ñ (—è–∫—â–æ —î)
    if (midnightShape) {
        midnightShape.y1 = lineYMax;
        shapes.push(midnightShape);
    }
    
    const currentTime = getCurrentTotalMinutes();
    
    // –î–æ–¥–∞—î–º–æ –ª—ñ–Ω—ñ—é "–ó–∞—Ä–∞–∑" (–≤–æ–Ω–∞ –º–∞—î –±—É—Ç–∏ –æ—Å—Ç–∞–Ω–Ω—å–æ—é, —â–æ–± –±—É—Ç–∏ –∑–≤–µ—Ä—Ö—É –≤—Å—ñ—Ö)
    shapes.push({
        type: "line",
        xref: "x",
        x0: currentTime, x1: currentTime,
        y0: -0.5, y1: lineYMax,
        line: { color: "#d32f2f", width: 2, dash: "solid" },
        layer: 'above'
    });

    const layout = {
        margin: { t: 50, b: 40, l: 40, r: 10 },
        xaxis: {
            title: "",
            range: [xMin, xMax], 
            tickvals: tickVals,
            ticktext: tickText,
            fixedrange: true,
            gridcolor: '#eee', // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞ —Å—ñ—Ç–∫–∞ (–ø—ñ–¥ —Å–º—É–≥–∞–º–∏) –¥–ª—è —ñ–Ω—à–∏—Ö –≥–æ–¥–∏–Ω
            showgrid: true
        },
        yaxis: {
            title: "",
            type: "category",
            categoryorder: "array",
            categoryarray: [...groups].reverse(),
            fixedrange: true,
            showgrid: true,
            zeroline: false
        },
        xaxis2: {
            title: "", overlaying: 'x', side: 'top',     
            range: [xMin, xMax], tickvals: tickVals, ticktext: tickText,
            fixedrange: true, showgrid: false, zeroline: false, automargin: true 
        },
        hovermode: 'closest',
        shapes: shapes,
        height: totalGroups * 50 + 80,
        annotations: [{
            x: currentTime, y: lineYMax, xref: 'x', yref: 'y',
            text: formatTime(currentTime % 1440),
            showarrow: false, yshift: 10,
            font: { color: '#d32f2f', size: 12, weight: 'bold' },
            bgcolor: 'rgba(255,255,255,0.9)', bordercolor: '#d32f2f',
            borderwidth: 1, borderpad: 2, opacity: 1
        }]
    };
    
    Plotly.newPlot("chart", traces, layout, {responsive: true, displayModeBar: false});
    startClockUpdate();
}

function formatTime(minutes) {
    const h = Math.floor(minutes / 60);
    const m = minutes % 60;
    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
}

function getCurrentTotalMinutes() {
    const now = new Date();
    return now.getHours() * 60 + now.getMinutes();
}

function startClockUpdate() {
    if (window.clockInterval) clearInterval(window.clockInterval);
    window.clockInterval = setInterval(() => {
        const current = getCurrentTotalMinutes();
        const timeStr = formatTime(current % 1440);
        
        // –ó–Ω–∞—Ö–æ–¥–∏–º–æ —ñ–Ω–¥–µ–∫—Å–∏ shapes –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è.
        // –û—Å—Ç–∞–Ω–Ω—ñ–π –µ–ª–µ–º–µ–Ω—Ç - —Ü–µ –∑–∞–≤–∂–¥–∏ "–ó–∞—Ä–∞–∑".
        // –Ø–∫—â–æ —î CombinedMode, –ø–µ—Ä–µ–¥–æ—Å—Ç–∞–Ω–Ω—ñ–π - —Ü–µ –ü—ñ–≤–Ω—ñ—á (midnightShape).
        // –ê–ª–µ –ø—Ä–æ—Å—Ç—ñ—à–µ –æ–Ω–æ–≤–∏—Ç–∏ –≤–µ—Å—å –≥—Ä–∞—Ñ—ñ–∫ —á–∞—Å—Ç–∫–æ–≤–æ –∞–±–æ –∑–Ω–∞–π—Ç–∏ —ñ–Ω–¥–µ–∫—Å –¥–∏–Ω–∞–º—ñ—á–Ω–æ.
        // –í —Ü—å–æ–º—É –∫–æ–¥—ñ –º–∏ –ø—Ä–æ—Å—Ç–æ –ø—Ä–∏–ø—É—Å–∫–∞—î–º–æ, —â–æ "–ó–∞—Ä–∞–∑" - —Ü–µ –æ—Å—Ç–∞–Ω–Ω—ñ–π –µ–ª–µ–º–µ–Ω—Ç.
        
        const chartDiv = document.getElementById('chart');
        if (chartDiv && chartDiv.layout && chartDiv.layout.shapes) {
            const lastShapeIndex = chartDiv.layout.shapes.length - 1;
            
            const update = {
                [`shapes[${lastShapeIndex}].x0`]: current,
                [`shapes[${lastShapeIndex}].x1`]: current,
                'annotations[0].x': current,
                'annotations[0].text': timeStr
            };
            Plotly.relayout("chart", update).catch(() => {});
        }
    }, 60000);
}

loadPowerData();
setInterval(() => loadPowerData(), 900000); 

</script>
</body>
</html>
